# Instance Graph 性能分析与优化方案

## 当前性能问题分析

### 1. 前端查询问题

#### 问题 1: 大量分页循环查询
```typescript
// 当前实现：对每个 linkType 都进行分页循环
for (const linkType of linkTypes) {
  while (hasMore) {
    const links = await linkApi.list(linkType.name, offset, limit);
    // 可能加载数千条关系
  }
}
```
**影响**：
- 如果有 10 个 linkType，每个有 1000 条关系，需要 50+ 次 HTTP 请求
- 网络延迟累积，总耗时 = 请求数 × 平均延迟

#### 问题 2: 预加载所有对象类型的实例
```typescript
// 当前实现：对每个 objectType 都加载 100-1000 个实例
for (const objType of objectTypes) {
  const limit = hasLinks ? 1000 : 100;
  const instances = await instanceApi.list(objType.name, 0, limit);
}
```
**影响**：
- 如果有 20 个 objectType，可能加载 2000-20000 个实例
- 大部分实例可能没有关系连接，浪费资源

#### 问题 3: N+1 查询问题
```typescript
// 当前实现：逐个查询缺失的节点
for (const nodeId of nodeIds) {
  if (!nodeMap.has(nodeId)) {
    const instance = await instanceApi.get(typeName, nodeId); // N+1 查询
  }
}
```
**影响**：
- 如果有 1000 个缺失节点，需要 1000 次 HTTP 请求
- 网络延迟累积严重

#### 问题 4: 没有节点数限制
- 可能加载数万个节点，导致：
  - 内存占用过高
  - 前端渲染性能下降
  - 浏览器卡顿

### 2. 后端性能问题

#### 问题 1: 低效的文件读取
```java
// 当前实现：每次都读取所有文件，然后才分页
try (Stream<Path> paths = Files.walk(dirPath)) {
    paths.filter(Files::isRegularFile)
        .forEach(p -> {
            Map<String, Object> instance = objectMapper.readValue(p.toFile(), Map.class);
            instances.add(instance); // 读取所有文件到内存
        });
}
return new ListResult(instances.subList(offset, end), total); // 最后才分页
```
**影响**：
- 即使只需要 20 条数据，也要读取所有文件
- 文件系统 I/O 操作频繁
- 内存占用高

#### 问题 2: 缺少批量查询接口
- 没有按 ID 列表批量获取实例的接口
- 前端只能逐个查询，导致 N+1 查询问题

## 优化方案

### 方案 1: 添加节点数限制和采样策略（快速优化）

**实现**：
1. 限制总节点数（例如最多 1000 个节点）
2. 当节点数超过限制时，采用采样策略：
   - 优先保留度（连接数）高的节点
   - 随机采样其他节点
3. 添加加载进度提示

**优点**：
- 实现简单，快速见效
- 不需要后端改动
- 可以立即改善用户体验

**缺点**：
- 可能丢失部分数据
- 不是根本性优化

### 方案 2: 实现后端批量查询接口（推荐）

**实现**：
1. 添加批量查询实例的 API：
   ```
   POST /api/v1/instances/batch
   Body: {
     "queries": [
       {"objectType": "Path", "ids": ["id1", "id2", ...]},
       {"objectType": "EntryTransaction", "ids": ["id3", "id4", ...]}
     ]
   }
   ```

2. 后端实现批量查询方法：
   ```java
   public Map<String, Map<String, Object>> getInstancesBatch(
       Map<String, List<String>> typeIdMap) {
     // 按类型分组，批量读取文件
   }
   ```

3. 前端优化：
   - 收集所有需要加载的节点 ID
   - 按类型分组
   - 一次性批量查询

**优点**：
- 解决 N+1 查询问题
- 大幅减少 HTTP 请求数
- 后端可以优化文件读取顺序

**缺点**：
- 需要后端改动
- 实现复杂度中等

### 方案 3: 优化加载策略（只加载有关系的节点）

**实现**：
1. 第一步：只加载关系，收集节点 ID
2. 第二步：批量查询这些节点 ID（使用方案 2 的批量接口）
3. 移除预加载所有实例的逻辑

**优点**：
- 大幅减少加载的数据量
- 只加载真正需要的节点
- 性能提升明显

**缺点**：
- 孤立节点不会显示（可能符合需求）

### 方案 4: 实现懒加载/按需展开

**实现**：
1. 初始只加载部分核心节点（例如度最高的节点）
2. 用户点击节点时，动态加载其邻居节点
3. 添加"展开"和"收起"功能

**优点**：
- 初始加载快
- 用户体验好
- 可以处理超大数据集

**缺点**：
- 实现复杂度高
- 需要前端交互优化

### 方案 5: 后端文件读取优化

**实现**：
1. 使用文件索引或缓存
2. 优化文件读取顺序（按需读取，不全部加载）
3. 实现流式处理

**优点**：
- 后端性能提升
- 内存占用降低

**缺点**：
- 需要较大的后端改动
- 实现复杂度高

## 推荐实施顺序

### 阶段 1: 快速优化（✅ 已完成）
1. ✅ **添加节点数限制**（最多 1000 个节点）
2. ✅ **优化加载策略**（只加载有关系的节点，移除预加载逻辑）
3. ✅ **添加采样策略**（当超过限制时，优先保留度高的节点）
4. ✅ **限制关系加载数量**（每个 linkType 最多 500 条关系）

### 阶段 2: 中期优化（✅ 已完成）
1. ✅ **实现后端批量查询接口**
   - `POST /api/v1/instances/{objectType}/batch` - 单个对象类型批量查询
   - `POST /api/v1/instances/batch` - 多个对象类型批量查询
2. ✅ **前端使用批量查询替代 N+1 查询**
   - 在 `GraphView.tsx` 中使用 `instanceApi.getBatchMultiType` 替代逐个查询
   - 从 N 次请求减少到 1 次请求
3. ✅ **优化关系加载逻辑**（限制每个 linkType 的最大加载数量）

### 阶段 3: 长期优化（按需）
1. ⚪ **实现懒加载/按需展开**
2. ⚪ **后端文件读取优化**
3. ⚪ **添加缓存机制**

## 预期效果

### 阶段 1 优化后（✅ 已实施）
- HTTP 请求数：从 100+ 减少到 20-30
- 加载时间：从 10-30 秒减少到 3-5 秒
- 节点数：从数万个减少到最多 1000 个
- 关系加载：每个 linkType 最多 500 条（特殊类型 1000 条）

### 阶段 2 优化后（✅ 已实施）
- HTTP 请求数：从 20-30 减少到 **5-10**（批量查询替代 N+1 查询）
- 加载时间：从 3-5 秒减少到 **1-2 秒**
- 内存占用：减少 50-70%
- 批量查询：一次请求可获取多个对象类型的多个实例

### 阶段 3 优化后
- 初始加载时间：< 1 秒
- 支持超大数据集（10万+ 节点）
- 用户体验流畅
